//===- PatmosInstrPatterns.td - Patmos Instruction Formats----*- tblgen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes Instruction selection patterns for Patmos.
//
//===----------------------------------------------------------------------===//

// zero in R0
def : Pat<(i32 0), (i32 R0)>;
// true in P0
def : Pat<(i1 -1), (i1  P0)>;

// load immediate
def : Pat<(i32 uimm12:$imm),  (LIi uimm12:$imm)>;
def : Pat<(i32 nuimm12:$imm), (LIin nuimm12:$imm)>;
def : Pat<(i32 imm:$imm),     (LIl (i32 imm:$imm))>;




// for zext-ing an i1 to i32: conditionally load 1 into an RReg
def : Pat<(zext (i1 predsel:$p)), (CADDi predsel:$p, (CLR), (i32 1))>;
def : Pat<(sext (i1 predsel:$p)), (CADDi predsel:$p, (CLR), (i32 1))>;
def : Pat<(anyext (i1 predsel:$p)), (CADDi predsel:$p, (CLR), (i32 1))>;

def : Pat<(sext_inreg RRegs:$r, i1), (SRAi (SLi RRegs:$r, (i32 31)), (i32 31))>;


// i1 promotion workarounds
def : Pat<(add predsel:$p1, predsel:$p2), (PXOR predsel:$p1, predsel:$p2)>;
def : Pat<(sub predsel:$p1, predsel:$p2), (PXOR predsel:$p1, predsel:$p2)>;



//def : Pat<(select RRegs:$rp, RRegs:$rs1, RRegs:$rs2), (CMOV (BTEST RRegs:$rp, 0), RRegs:$rs1, RRegs:$rs2)>;

def : Pat<(select predsel:$p, RRegs:$new, uimm12:$imm), (CMOV predsel:$p, (LIi uimm12:$imm), RRegs:$new)>;
def : Pat<(select predsel:$p, RRegs:$new, nuimm12:$imm), (CMOV predsel:$p, (LIin nuimm12:$imm), RRegs:$new)>;
def : Pat<(select predsel:$p, RRegs:$new, (i32 imm:$imm)), (CMOV predsel:$p, (LIl (i32 imm:$imm)), RRegs:$new)>;



// Arithmetic optimizations //////////////////////////////////////////////////

def : Pat<(add RRegs:$rs, nuimm12:$imm), (SUBi RRegs:$rs, nuimm12:$imm)>;

// p={0|1} * sth = (p) LI/MOV sth
def : Pat<(mul (zext (i1 predsel:$p)), uimm12:$imm),
          (CLIi predsel:$p, uimm12:$imm)>;
def : Pat<(mul (zext (i1 predsel:$p)), (i32 imm:$imm)),
          (CLIl predsel:$p, (i32 imm:$imm))>;
def : Pat<(mul (zext (i1 predsel:$p)), RRegs:$rs),
          (CMOV predsel:$p, (CLR), RRegs:$rs)>;


// shadd/shadd2 instead of mul 3/5
def : Pat<(mul RRegs:$r, (i32 3)), (SHADDr RRegs:$r, RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32 5)), (SHADD2r RRegs:$r, RRegs:$r)>;

// following mul by constant patterns only pay off if mul takes > 2 cycles
// and offers no immediate variant
// mul x, (3 * 2^n)
def : Pat<(mul RRegs:$r, (i32   6)), (SLi (SHADDr RRegs:$r, RRegs:$r), 1)>;
def : Pat<(mul RRegs:$r, (i32  12)), (SLi (SHADDr RRegs:$r, RRegs:$r), 2)>;
def : Pat<(mul RRegs:$r, (i32  24)), (SLi (SHADDr RRegs:$r, RRegs:$r), 3)>;
def : Pat<(mul RRegs:$r, (i32  48)), (SLi (SHADDr RRegs:$r, RRegs:$r), 4)>;
def : Pat<(mul RRegs:$r, (i32  96)), (SLi (SHADDr RRegs:$r, RRegs:$r), 5)>;
def : Pat<(mul RRegs:$r, (i32 192)), (SLi (SHADDr RRegs:$r, RRegs:$r), 6)>;
def : Pat<(mul RRegs:$r, (i32 384)), (SLi (SHADDr RRegs:$r, RRegs:$r), 7)>;
def : Pat<(mul RRegs:$r, (i32 768)), (SLi (SHADDr RRegs:$r, RRegs:$r), 8)>;
// mul x, (5 * 2^n)
def : Pat<(mul RRegs:$r, (i32   10)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 1)>;
def : Pat<(mul RRegs:$r, (i32   20)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 2)>;
def : Pat<(mul RRegs:$r, (i32   40)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 3)>;
def : Pat<(mul RRegs:$r, (i32   80)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 4)>;
def : Pat<(mul RRegs:$r, (i32  160)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 5)>;
def : Pat<(mul RRegs:$r, (i32  320)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 6)>;
def : Pat<(mul RRegs:$r, (i32  640)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 7)>;
def : Pat<(mul RRegs:$r, (i32 1280)), (SLi (SHADD2r RRegs:$r, RRegs:$r), 8)>;
// mul x, (2^n + 1) = x<<n + x
// for n>2
def : Pat<(mul RRegs:$r, (i32   9)), (ADDr (SLi RRegs:$r, 3), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  17)), (ADDr (SLi RRegs:$r, 4), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  33)), (ADDr (SLi RRegs:$r, 5), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  65)), (ADDr (SLi RRegs:$r, 6), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32 129)), (ADDr (SLi RRegs:$r, 7), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32 257)), (ADDr (SLi RRegs:$r, 8), RRegs:$r)>;
// mul x, (2^n - 1) = x<<n - x
// for n>2
def : Pat<(mul RRegs:$r, (i32   7)), (SUBr (SLi RRegs:$r, 3), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  15)), (SUBr (SLi RRegs:$r, 4), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  31)), (SUBr (SLi RRegs:$r, 5), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32  63)), (SUBr (SLi RRegs:$r, 6), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32 127)), (SUBr (SLi RRegs:$r, 7), RRegs:$r)>;
def : Pat<(mul RRegs:$r, (i32 255)), (SUBr (SLi RRegs:$r, 8), RRegs:$r)>;



// jump-table.
def : Pat<(i32 tjumptable:$dst), (LIl tjumptable:$dst)>;
def : Pat<(i32 jtpat:$dst), (LIl jtpat:$dst)>;

// global addresses, external symbols, and frame indices
def : Pat<(gspat:$sym), (LIl gspat:$sym)>;
def : Pat<(espat:$sym), (LIl espat:$sym)>;

def : Pat<(add gspat:$sym, RRegs:$r), (ADDl RRegs:$r, gspat:$sym)>;
def : Pat<(add espat:$sym, RRegs:$r), (ADDl RRegs:$r, espat:$sym)>;

def : Pat<(add gspat:$sym, (shl RRegs:$r, (i32 1))), (SHADDl RRegs:$r, gspat:$sym)>;
def : Pat<(add espat:$sym, (shl RRegs:$r, (i32 1))), (SHADDl RRegs:$r, espat:$sym)>;

def : Pat<(add gspat:$sym, (shl RRegs:$r, (i32 2))), (SHADD2l RRegs:$r, gspat:$sym)>;
def : Pat<(add espat:$sym, (shl RRegs:$r, (i32 2))), (SHADD2l RRegs:$r, espat:$sym)>;

def : Pat<(fipat:$fi) , (ADDi fipat:$fi, 0)>;
def : Pat<(add fipat:$fi, imm7:$imm) , (ADDi fipat:$fi, imm7:$imm)>;
def : Pat<(add fipat:$fi, imm:$imm) , (ADDl fipat:$fi, imm:$imm)>;

def : Pat<(PatmosCall tglobaladdr:$sym), (CALL tglobaladdr:$sym)>;
def : Pat<(PatmosCall texternalsym:$sym), (CALL texternalsym:$sym)>;

def : Pat<(PatmosReturn ), (RET RFB, RFO)>;

// multiplication (requiring only low part)
def : Pat<(mul RRegs:$rs1, RRegs:$rs2),
          (COPY_TO_REGCLASS (MUL RRegs:$rs1, RRegs:$rs2), RRegs)>;


// Compare patterns

def : Pat<(seteq  RRegs:$a, RRegs:$b), (CMPEQ  RRegs:$a, RRegs:$b)>;
def : Pat<(setne  RRegs:$a, RRegs:$b), (CMPNEQ RRegs:$a, RRegs:$b)>;
def : Pat<(setlt  RRegs:$a, RRegs:$b), (CMPLT  RRegs:$a, RRegs:$b)>;
def : Pat<(setle  RRegs:$a, RRegs:$b), (CMPLE  RRegs:$a, RRegs:$b)>;
def : Pat<(setult RRegs:$a, RRegs:$b), (CMPULT RRegs:$a, RRegs:$b)>;
def : Pat<(setule RRegs:$a, RRegs:$b), (CMPULE RRegs:$a, RRegs:$b)>;
// we find paterns for inverted conditions (instead of Patmos pseudo instructions)
def : Pat<(setgt  RRegs:$b, RRegs:$a), (CMPLT  RRegs:$a, RRegs:$b)>;
def : Pat<(setge  RRegs:$b, RRegs:$a), (CMPLE  RRegs:$a, RRegs:$b)>;
def : Pat<(setugt RRegs:$b, RRegs:$a), (CMPULT RRegs:$a, RRegs:$b)>;
def : Pat<(setuge RRegs:$b, RRegs:$a), (CMPULE RRegs:$a, RRegs:$b)>;

def : Pat<(setne (and RRegs:$a, (shl (i32 1), RRegs:$b)), (i32 0)),
          (BTEST RRegs:$a, RRegs:$b)>;
def : Pat<(setne (and RRegs:$a, uimm5mask:$b), (i32 0)),
          (BTEST RRegs:$a, (LIi uimm5mask:$b))>;
def : Pat<(seteq (and RRegs:$a, uimm5mask:$b), uimm5mask:$b),
          (BTEST RRegs:$a, (LIi uimm5mask:$b))>;

// Predicate Combine patterns

def : Pat<(or  predsel:$ps1, predsel:$ps2), (POR  predsel:$ps1, predsel:$ps2)>;
def : Pat<(and predsel:$ps1, predsel:$ps2), (PAND predsel:$ps1, predsel:$ps2)>;
def : Pat<(xor predsel:$ps1, predsel:$ps2), (PXOR predsel:$ps1, predsel:$ps2)>;


def : Pat<(setne  predsel:$a, (i1 -1)), (PNOT predsel:$a)>;

def : Pat<(i1 (trunc RRegs:$a)), (ISODD RRegs:$a)>;


// inst_C: instruction to use for data load
multiclass LoadTypedPatterns<PatmosInst inst, PatFrag immFg, PatFrag pfg>
{
  // load register indirect from cache
  def ra : Pat<(pfg RRegs:$ra), (inst RRegs:$ra, 0)>;

  // load register indirect + immediate from cache
  def raimm : Pat<(pfg (add RRegs:$ra, immFg:$imm)),
                  (inst RRegs:$ra, immFg:$imm)>;

  // load register indirect from cache
  def fi : Pat<(pfg fipat:$fi), (inst fipat:$fi, 0)>;

  // load register indirect from cache
  def fiimm : Pat<(pfg (add fipat:$fi, immFg:$imm)),
                  (inst fipat:$fi, immFg:$imm)>;

  def fior : Pat<(pfg (or fipat:$fi, immFg:$imm)),
                  (inst fipat:$fi, immFg:$imm)>;

  // TODO: more patterns here
}

class cachedLoad<PatFrag patLoad> : PatFrag<(ops node:$ptr), (patLoad node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 0 && !cast<MemSDNode>(N)->isNonTemporal();
	    }]>;

class uncachedLoad<PatFrag patLoad> : PatFrag<(ops node:$ptr), (patLoad node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 0 && cast<MemSDNode>(N)->isNonTemporal();
	    }]>;

class spmLoad<PatFrag patLoad> : PatFrag<(ops node:$ptr), (patLoad node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 1;
	    }]>;

// feel free to use multiclass if you find out how to make them work ..
defm LW   : LoadTypedPatterns<LWC , uimm7s2, cachedLoad<load>>;
defm LH   : LoadTypedPatterns<LHC , uimm7s1, cachedLoad<sextloadi16>>;
defm LB   : LoadTypedPatterns<LBC , uimm7  , cachedLoad<sextloadi8>>;
defm LHU  : LoadTypedPatterns<LHUC, uimm7s1, cachedLoad<zextloadi16>>;
defm LBU  : LoadTypedPatterns<LBUC, uimm7  , cachedLoad<zextloadi8>>;
defm LHE  : LoadTypedPatterns<LHUC, uimm7s1, cachedLoad<extloadi16>>;
defm LBE  : LoadTypedPatterns<LBUC, uimm7  , cachedLoad<extloadi8>>;
defm LWM  : LoadTypedPatterns<LWM , uimm7s2, uncachedLoad<load>>;
defm LHM  : LoadTypedPatterns<LHM , uimm7s1, uncachedLoad<sextloadi16>>;
defm LBM  : LoadTypedPatterns<LBM , uimm7  , uncachedLoad<sextloadi8>>;
defm LHUM : LoadTypedPatterns<LHUM, uimm7s1, uncachedLoad<zextloadi16>>;
defm LBUM : LoadTypedPatterns<LBUM, uimm7  , uncachedLoad<zextloadi8>>;
defm LHEM : LoadTypedPatterns<LHUM, uimm7s1, uncachedLoad<extloadi16>>;
defm LBEM : LoadTypedPatterns<LBUM, uimm7  , uncachedLoad<extloadi8>>;

defm LWL  : LoadTypedPatterns<LWL , uimm7s2, spmLoad<load>>;
defm LHL  : LoadTypedPatterns<LHL , uimm7s1, spmLoad<sextloadi16>>;
defm LBL  : LoadTypedPatterns<LBL , uimm7  , spmLoad<sextloadi8>>;
defm LHUL : LoadTypedPatterns<LHUL, uimm7s1, spmLoad<zextloadi16>>;
defm LBUL : LoadTypedPatterns<LBUL, uimm7  , spmLoad<zextloadi8>>;
defm LHEL : LoadTypedPatterns<LHUL, uimm7s1, spmLoad<extloadi16>>;
defm LBEL : LoadTypedPatterns<LBUL, uimm7  , spmLoad<extloadi8>>;

// store patterns


multiclass StoreTypedPatterns<PatmosInst inst_C, PatFrag immFg, PatFrag pfg>
{
  // load register indirect from cache
  def ra : Pat<(pfg RRegs:$rs, RRegs:$ra),
               (inst_C RRegs:$ra, 0, RRegs:$rs)>;

  // load register indirect + immediate from cache
  def raimm : Pat<(pfg RRegs:$rs, (add RRegs:$ra, immFg:$imm)),
                  (inst_C RRegs:$ra, immFg:$imm, RRegs:$rs)>;

  // load register indirect from cache
  def fi : Pat<(pfg RRegs:$rs, fipat:$fi),
               (inst_C fipat:$fi, 0, RRegs:$rs)>;

  // load register indirect from cache
  def fiimm : Pat<(pfg RRegs:$rs, (add fipat:$fi, immFg:$imm)),
                  (inst_C fipat:$fi, immFg:$imm, RRegs:$rs)>;

  def fior  : Pat<(pfg RRegs:$rs, (or fipat:$fi, immFg:$imm)),
                  (inst_C fipat:$fi, immFg:$imm, RRegs:$rs)>;

  // TODO: more patterns here
}

class cachedStore<PatFrag patStore> : PatFrag<(ops node:$val, node:$ptr), (patStore node:$val, node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 0 && !cast<MemSDNode>(N)->isNonTemporal();
	    }]>;

class uncachedStore<PatFrag patStore> : PatFrag<(ops node:$val, node:$ptr), (patStore node:$val, node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 0 && cast<MemSDNode>(N)->isNonTemporal();
	    }]>;

class spmStore<PatFrag patStore> : PatFrag<(ops node:$val, node:$ptr), (patStore node:$val, node:$ptr), [{
		return cast<MemSDNode>(N)->getAddressSpace() == 1;
	    }]>;


defm SW  : StoreTypedPatterns<SWC, uimm7s2, cachedStore<store>>;
defm SH  : StoreTypedPatterns<SHC, uimm7s1, cachedStore<truncstorei16>>;
defm SB  : StoreTypedPatterns<SBC, uimm7  , cachedStore<truncstorei8>>;
defm SWM : StoreTypedPatterns<SWM, uimm7s2, uncachedStore<store>>;
defm SHM : StoreTypedPatterns<SHM, uimm7s1, uncachedStore<truncstorei16>>;
defm SBM : StoreTypedPatterns<SBM, uimm7  , uncachedStore<truncstorei8>>;
defm SWL : StoreTypedPatterns<SWL, uimm7s2, spmStore<store>>;
defm SHL : StoreTypedPatterns<SHL, uimm7s1, spmStore<truncstorei16>>;
defm SBL : StoreTypedPatterns<SBL, uimm7  , spmStore<truncstorei8>>;


// Branch via JumpTable

def : Pat<(brjt jtpat:$jtable, RRegs:$index),
          (BRTu (LWC (SHADD2l RRegs:$index, jtpat:$jtable), 0), jtpat:$jtable)>;

